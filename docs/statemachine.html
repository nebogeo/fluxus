<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><title>Fluxus manual v0.8</title><link rel="stylesheet" href="fluxusdoc.css"></head><body>
<hdr>Fluxus manual v0.8 : (C) 2005 Dave Griffiths : dave at pawfal dot org : <a href="http://www.pawfal.org">www.pawfal.org</a></hdr>

<h1>4.0  The Fluxus State Machine</h1>
Like OpenGL, fluxus is a state machine which has a renderstate you can modify 
to describe objects created later. for example:

<c>(colour (vector 1 0 0))
(draw-cube)
(colour (vector 0 1 0))
(draw-cube)</c>

will draw a red cube, then a green cube
states can also be stacked, for example:

<c>(colour (vector 1 0 0))
(push)
	(colour (vector 0 1 0))
	(draw-cube)
(pop)
(draw-cube)</c>

will draw a green, then a red cube.

<big>4.1  The Scenegraph </big>

Both examples so far have used what is known as immediate mode, you have one 
state stack, the top of which is the current context, and everything is drawn 
once per frame. fluxus contains a structure known as a scenegraph for storing 
objects and their render states.

Time for another example:

<c>(colour (vector 1 0 0))
(build-cube)
(colour (vector 0 1 0))
(build-cube)</c>

The only difference between this and the first example is the use of 
(build-cube) instead of (draw-cube). the build functions create a primitive 
object, copy the current renderstate and add the information into the 
scenegraph in a container called a scenenode.

The (build-*) functions return object ID's (just numbers really) which enable 
you to do things to the scene node after it's been created. you can now specify 
objects like this:

<c>(define myob (build-cube))</c>

The cube will now be persistant in the scene until destroyed with

<c>(destroy myob)</c>

If you want to modify a objects renderstate after it's been loaded into the 
scenegraph, you can use the grab function to temporarially set the current 
context to that of the object. use ungrab to turn fluxus back into normal 
state stack mode. this allows you to animate objects stored in the scenegraph, 
for instance:

<c>(colour (vector 1 1 1))
(define obj1 (build-cube))
(push)
    (translate (vector 2 0 0))
    (define obj2 (build-cube))
(pop)</c>

--->8---

; in a function called per frame

<c>(grab obj1)
(rotate (vector 0 1 0))
(ungrab)

(grab obj2)
(rotate (vector 0 0 1))
(ungrab)</c>

Do not call push or pop while an object is grabbed, it will have no effect - 
fluxus will print out a warning in this case.

The scenegraph also enables you to parent objects to one another, using the 
renderstate's parent setting. this is only effective before an object is loaded 
into the scenegraph, setting it afterwards via a grabbed state will be 
ignored:

<c>(colour (vector 1 1 1))
(define a (build-cube))

(push)
    (parent a)
    (translate (vector 0 2 0))
    (define b (build-cube))
(pop)

(push)
    (parent b)
    (translate (vector 0 2 0))
    (define c (build-cube))
(pop)</c>

creates three cubes, all attached to each other in a chain. transforms for 
object a will be passed down to b and c, transforms on b will effect c blah.

destroying a object in such a hierachy will in turn destroy all child objects 
parented to it.

<c>(apply obj)</c>

applies the tranformation stored in the object's scene graph node directly to 
the vertices of the geometry, and sets the transform to identity. this means 
that you can change the origin of the object, and therefore the parent pivot 
position.
